---
title: '[JS] 자바스크립트 데이터 타입'
date: 2021-06-09 21:05:13
category: 'fundamental'
draft: false
---

# 데이터 타입

데이터 타입은 프로그래밍 언어에서 사용하는 데이터의 종류를 말한다. 자바스크립트의 데이터 타입은 크게 원시 타입과 참조 타입 두 종류로 나뉜다.

일반적으로 원시 타입은 할당이나 연산시에 복제되고, 참조 타입은 참조된다고 알려져있다. 하지만 엄밀히 따져보면 원시 타입과 참조 타입 모두 복제된다. 원시 타입은 값이 담긴 주솟값을 바로 복제하고, 참조 타입은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제하기 때문에 복제하는 대상이 다를 뿐이다.

<br />

## 원시 타입 (Primitive type)

원시 타입은 불변성을 띈다.

<br/>

> **불변성 (immutable value)**
>
> ```javascript
> let variable = 'a'
> variable = 'b'
> ```
>
> '불변성'이라는 것은 재할당이 불가능하다는 뜻이 아닌 메모리 영역에 저장된 값 자체가 변경되는 것이 아님을 뜻한다. 메모리 영역에서는 주솟값이 변경된다.
>
> ![immutable value table](https://images.velog.io/images/anachrosh/post/3c47a994-e5d9-4fb0-bcf3-59573dc721f7/image.png)
> 첫번째 구문이 실행되면 메모리의 빈 공간 중 하나를 확보한다. 여기에서는 임의로 @2를 확보했다. 확보한 @2에 식별자로 variable을 지정하고, 별도의 빈 공간 @13에 문자열 'a'를 저장한다. 그 후 variable이라는 식별자가 있는 공간에 'a'가 저장되어 있는 @13이라는 주솟값을 대입한다.
>
> 이어 두번째 구문이 실행되면 빈 메모리 공간을 확보해 문자열 'b'를 저장한 뒤(여기서는 임의의 공간 @14), variable이라는 식별자가 있는 @2 공간에 저장된 값 주소를 @14로 변경한다.
>
> 위의 경우 문자열 'a'와 'b' 모두가 메모리에 존재하고 있고 variable이 가리키는 대상이 변경되었을 뿐이다. 이것이 원시 타입이 '불변성'을 띄고 있다고 설명하는 이유이다.

<br />

### 원시 타입의 종류

- **boolean**

  논리적 참, 거짓을 나타내는 true / false

- **null**

  의도적으로 변수에 값이 없다는 것을 명시할 때 사용되는 값

- **undefined**

  의도적으로 할당하는 값이 아닌 자바스크립트 엔진에 의해 초기화된 값. 선언은 되었지만 값이 할당되지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우 반환됨.

- **number**

  JS는 하나의 숫자 타입만이 존재하기 때문에 정수, 실수 음의 정수, 2진수, 8진수, 16진수 등이 모두 10진수로 해석된다. number 타입에는 Infiniy(양의 무한대), -Infinity(음의 무한대), NaN(Not a Number, 산술 연산 불가)와 같은 특별한 값을 표현할 수 있는 형식도 포함되어 있다.

- **string**

  작은 따옴표('') 또는 큰 따옴표("")로 표현되는 문자열

- **symbol**

<br />
<br />

## 참조 타입 (object/reference type)

참조 타입은 원시 타입과 반대로 '가변성'을 가지고 있다. 하지만 원시 타입이 모두 불변성을 띄고 있는 것과는 다르게 참조 타입은 기본적인 성질은 가변값이지만 설정에 따라 변경 불가능한 경우도 있고 의도적으로 불변값으로 활용하는 방법도 있다.

<br/>

> **mutable value**
>
> 객체는 프로퍼티(키와 값으로 구성)를 변경, 추가, 삭제할 수 있기 때문에 변경 가능한 값이라 한다. 이는 동적으로 변화할 수 있다는 뜻으로 어느 정도의 메모리 공간을 확보해야 하는지 예측이 어렵다.
>
> ```javascript
> let obj = {
>   a: 10,
>   b: 'abc',
> }
> obj.a = 20
> ```
>
> 참조 타입은 메모리 상에 '객체의 프로퍼티를 저장하는 영역'이 별도로 존재하기 때문에 가변성을 가질 수 있다. 즉, 값이 변경될 때 원시 타입처럼 식별자가 있는 공간의 주솟값이 바로 변경되는 것이 아니라 객체의 프로퍼티를 저장하는 영역의 주솟값이 변경되는 것이다.
>
> ![mutable value table](https://images.velog.io/images/anachrosh/post/6e4687d6-dd9b-4a6c-80a0-ed45323fb94e/image.png)
>
> 첫번째 구문이 실행되면 메모리의 빈 공간 중 하나를 확보해 obj를 지정한다.(예시에서는 @2) 그 후, 임의의 공간 @11에 값을 저장하려는데 저장해야 하는 값이 여러 개의 변수와 값이 모여있는 객체이다. 이럴 경우 이것들을 저장하기 위해 별도의 영역(@21~)을 마련하고 그 주솟값을 @11에 저장한다.
>
> @21에 식별자 a, @12에 값 10을 저장하고 @21의 값으로 주솟값 @12를 준다. obj의 나머지 프로퍼티도 이와 마찬가지로 @22에 식별자 b, @13에 'abc'를 저장하고 @22의 값으로 주솟값 @13을 저장한다. 여기까지가 참조 타입 데이터가 메모리에 저장되는 단계이다.
>
> 이어서 코드의 `obj.a = 20`을 실행시키면, 메모리 상에 20이라는 데이터가 없으므로 임의의 공간 @14에 20이라는 데이터를 저장한다. 그리고 obj.a에 해당하는 @21 내부에 저장된 주솟값 @12가 @14로 변경된다.
>
> 참조 타입은 데이터 내부 값이 변경되어도 obj라는 식별자가 가진 값이 직접적으로 변경되지 않는다. obj라는 식별자가 가진 값(@11)의 하위 값(@21~)이 변경되는 것이다. 내부의 값을 변경하는 과정에서 obj라는 식별자의 값 자체가 변경되지 않았기 때문에 참조 타입은 '가변성'을 가지고 있다고 말하는 것이다.

<br />

### 참조 타입의 종류

- **object**

  참조형에는 객체가 있고, 배열, 함수, 날짜, 정규표현식 등 원시 타입에 속하지 않는 모든 것이 객체이다.

<br/>
<br/>
<br/>
<br/>
