---
title: '[Book] Refactoring 2판 4장'
date: 2022-05-27 09:10:13
category: 'fundamental'
draft: false
---

# 리팩터링 2판 4장 - 테스트 구축하기

개발자가 작성하는 코드에는 불가피하게 저지르는 실수가 발생하기 마련인데, 테스트는 이를 해결하는 것에 아주 큰 역할을 한다. 또한, 자가 테스트 코드를 작성하는 것은 물론이고 테스트를 자주 수행하는 습관 자체도 버그를 찾는 것에 강력한 도움이 된다.

<br/>

## 테스트가 어려운 이유

**1. 소프트웨어 제품 외에 부가적인 코드 작성량이 상당하다**

당연한 이야기지만 테스트를 수행하기 위해서는 적절한 테스트 코드를 작성해야 한다. 작성해야 하는 코드의 양이 증가한다는 것은 심리적인 부담이 될 수 있다.

<br/>

**2. 위의 이유로 전체적인 개발 속도가 저하되는 것처럼 느껴질 수 있다**

작성해야 하는 코드의 절대량이 늘면, 자연스럽게 업무 진척 속도가 느려지는 것 같은 기분이 든다.

<br/>

**3. 테스트 작성법을 배우지 않은 개발자가 많다**

테스트는 필수가 아닌 부가적인 것으로 여겨지는 경우가 있어 많은 수의 개발자들이 테스트 작성법에 대해 알지 못하는 경우가 많다. 그리고 새로운 것을 배우는 것은 이유를 막론하고 부담스럽게 느껴지기도 한다.

<br/>

테스트를 하지 않는 개발자들이 테스트에 거부감을 가지는 이유는 보통 위의 세 가지 이유이다. 하지만 이 책의 저자는 그럼에도 불구하고 테스트를 반드시 구축해야 하며, 리팩터링에는 테스트가 필수 요소라고 설명하고 있다.

테스트 작성법을 공부하고 테스트를 작성하는 것이 당장은 개발 속도를 저하시키는 것처럼 느껴지겠지만 전체적인 관점에서 보았을 때 코드의 퀄리티와 속도 모두를 향상시키기 때문이다. 어디에서 발생했는지 모를 버그를 찾아 해결하기 위해서 짧게는 반나절부터 길게는 며칠 단위로 고생해본 경험이 있다면 쉽게 동의할 수 있을 것이다.

<br/>

## 테스트 작성 시 주의사항

**테스트는 어디까지나 버그를 찾는 것이 목적이기 때문에 위험 요인을 중심으로 작성해야 한다.**

테스트를 너무 많이 만들다 보면 오히려 필요한 테스트를 놓칠 수 있기 때문에 걱정되는 영역을 집중적으로 테스트 하는 것이 중요하다. 예를 들어 단순히 필드를 읽고 쓰기만 하는 접근자는 테스트할 필요가 없다.

또한, **테스트를 작성할 때는 코드의 성격에 따라 분리하는 것이 좋다.**

HTML의 생성, 값 변경에 따른 로직 적용, 비즈니스 로직 또는 UI 등 코드를 파악하고 테스트하기 좋은 단위로 쪼개서 진행해야 테스트를 작성하는 것 자체도 간단해지고 테스트 결과도 명확하게 얻을 수 있다.

<br/>

## 테스트 구축과 흐름

해당 책에서는 생산 계획을 검토하고 수정하도록 하는 애플리케이션을 예시로 자바스크립트용 테스트 프레임워크인 모카를 사용한다.

> **MOCHA(모카)**
>
> 테스트 러너를 지원하는 테스트 프레임워크로 자체 assertion은 지원하지 않지만 필요한 assertion 라이브러리를 가져와 사용할 수 있다. 또한, 테스트 코드를 블록 단위로 나눠 각 블록에 테스트 스위트를 담는 구조로 되어있다.
>
> - describe: 테스트의 범위 설정
> - it: 단위 테스트 설정
> - fixture: 테스트 실행을 위해 베이스라인으로 사용되는 객체들의 고정된 상태

<br/>

모카로 작성된 테스트 코드는 아래의 코드와 같은 형식을 가지고 있다. 해당 책은 테스트 작성법이 아닌 리팩터링이 주제이기 때문에 직접적인 테스트 작성법은 대략적으로만 이해해도 괜찮다.

```javascript
describe('province', function() {
  it('shortfall', function() {
    const asia = new Province(sampleProvinceData()) // 픽스처 설정
    assert.equal(asia.shortfall, 5) // 검증
  })
})

// 테스트 결과 예시   1 passing (61ms)
```

테스트를 작성할 때 중요한 것은 `실패해야 할 상황에서는 반드시 실패하게 만들어야 한다`는 것이다. 실패하는 테스트 없이 모두 성공된다면 작성한 테스트에 문제가 있는 것은 아닌지 확인해야 한다. 이를 위해 고의적으로 오류를 주입하기도 한다.

위의 과정대로 첫 테스트를 완료했다면 계속해서 테스트를 추가해야 한다. 테스트를 추가할 때는 앞서 말했듯이 `위험 요소 중심`으로 작성하도록 하자.

위의 조건들을 기억하며 테스트를 작성하다 보면 한 가지 더 주의해야 할 점이 있다. 소프트웨어를 사용하는 `모든 유저가 우리의 생각과 의도대로만 사용하지는 않을 수 있다`는 점이다. 예를 들어, 양의 숫자를 입력해야 하는 필드에 0이나 음수를 입력하거나, 수요가 음수일 때 수익도 음수로 나오는 경우이다. 이런 경우에는 정상적인 경우와는 다른 처리가 필요하다. 그렇기 때문에 사용자 관점에서 생각해 예외 상황을 처리할 수 있는 테스트도 작성하는 것이 좋다. 이런 경우를 `경계 조건 검사`라고 부른다.

<br/>

## 참고

**TDD(Test-Driven Development)**

처음에는 통과하지 못할 테스트를 작성하고, 이 테스트를 통과하게끔 코드를 작성한다. 그 후 결과 코드를 최대한 깔끔하게 리팩터링 하는 과정을 짧은 주기로 반복한다.

**test case**

하나의 메소드를 테스트하기 위한 테스트 메소드

**test suite**

테스트 케이스들을 하나로 묶은 것. 테스트 스위트를 정의하면 특정한 클래스나 특정한 메소드들을 선택해 단위 테스트를 진행할 수 있다.

**Unit test(단위 테스트)**

프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행해 예상대로 동작하는지 확인하는 테스트

**Integration test(통합 테스트)**

단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈을 모아 의도대로 동작하는지 확인하는 테스트
단위 테스트와 달리 개발자가 변경할 수 없는 부분(ex. 외부 라이브러리, DB 접근 등)까지 묶어 검증한다.
단위 테스트에서 발견하기 어려운 버그를 찾을 수 있다는 장점이 있으나, 한 번에 많은 코드를 실행하기 때문에(단위 테스트와 비교해) 신뢰성이 떨어지고 에러 발생 부분을 확인하기 어렵다는 단점이 있다.

**Acceptance test(인수 테스트)**

사용자 스토리(시나리오)에 맞춰 수행하는 테스트
단위 테스트나 인수 테스트와는 다르게 비즈니스 쪽에 초점을 두고 있다.
시나리오를 만들고 이에 의거해 테스트 코드를 작성한다.
소프트웨어 내부 구조나 구현 방법보다는 실제 사용자 관점을 중요시하는 테스트이다.

<br/>

- [mochajs.org](https://mochajs.org/)
- [TDD](https://www.guru99.com/test-driven-development.html)

<br/>
<br/>
<br/>
<br/>
